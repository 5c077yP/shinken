<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"
	  [
	  <!ENTITY % all.entities SYSTEM "../all-entities.ent">
	  %all.entities;
	  ]
	  >
<chapter id="development-hackingcode" xreflabel="Hack Shinken code">
  <title>Hacking Shinken Code</title>
  <section>
    <title>Goal of code hacking (developement)</title>
    <para>Shinken is an open source program. If you find something
      broken or an enhancement, you can create a patch and send it to
      the developement mailing list.
    </para>
    <para>
      This documentation will show how to add code in the Shinken
      program. Shinken is coded in Python, so the only thing you need,
      is to learn this (very easy) language.
    </para>
  </section>
  <section>
    <title>How is organized then Shinken's code</title>
    <para>
      All the Shinken code is in the src directory. All important
      source files are :
      <itemizedlist>
	<listitem>
	  <para>shinken-*py : source files of daemons
	  </para>
	</listitem>
	<listitem>
	  <para>item.py : based class for nearly all important objects
	  like hosts, services and contacts.
	  </para>
	</listitem>
	<listitem>
	  <para>*link.py : class used by Arbiter to connect to daemons.
	  </para>
	</listitem>
	<listitem>
	  <para>modules/*/*py : modules for daemons (like Broker).
	  </para>
	</listitem>
	<listitem>
	  <para>schedulingitem.py : based class for host/service that
	  defined all algorithm for scheduling things.
	  </para>
	</listitem>
      </itemizedlist>
    </para>
  </section>
  <section>
    <title>The Datadriven programing in Shinken code</title>
    <para>
      A very important thing in Shinken code is the data programming
      method : instead of hardcoding transformation for properties,
      it's better to have a array (dict in Python) that described all
      transformations we can use on theses properties.
    </para>
    <para>
      With this method, a developer only need to add this description,
      and all tranformations will be automatic (like configuration
      parsing, inheritance application, etc).
    </para>
    <para>Nearly all important classes have such an array. It's named
      "properties" and is attached to the classe, not the object itself.
    </para>
    <para>Global parameter of the application (the one of the
    nagios.cfg file) are in the properties of the Config class. They
    are defined like:
      'enable_notifications' : {'required':False, 'default':'1', 'pythonize': to_bool, 'class_inherit' : [(Host, None), (Service, None), (Contact, None)]},
    </para>
    <para>
      Here, this property is:
      <itemizedlist>
	<listitem>
	  <para>not required</para>
	</listitem>
	<listitem>
	  <para>It's defualt value is 1</para>
	</listitem>
	<listitem>
	  <para>We use the 'to_bool' function to transform the string
	  from the configuration file to a Python object
	  </para>
	</listitem>
	<listitem>
	  <para>We put this value in the Host and Service class with
	  the same name (None==keep the name). If a string we in place
	  of None, this string is used to access this properti from
	  the class.
	  </para>
	</listitem>
      </itemizedlist>
    </para>
    <para>Specific properties for objects like Hosts or Services are
    in a properties dict, but without the 'class_inherit'
    part. Instead of this, they have the "fill_brok" part. It's used
    to know ifthe property must be send in theses brok types:
      <itemizedlist>
	<listitem>
	  <para>full_status : send a full status brok, like at daemon starting.</para>
	</listitem>
	<listitem>
	  <para>check_result : send when a check came back</para>
	</listitem>
	<listitem>
	  <para>next_schedule : send when a new check is scheduled</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>Theses classes also have another "properties" like dict :
    running_properties. It's like the standart one, but for running
    only properties (aka no configuration based properties).
    </para>
  </section>
  <section>
    <title>Exemple of code hacking : add a parameter for the flapping history</title>
    <para>
      In Nagios code, the flapping state history size is hard coded
      (20). As in the first Shinken realease. Let see how it work to
      add such a parameter in the global file and use it in the
      scheduling part of the code.
    </para>
    <para>
      We will see that adding such a parameter is very (very)
      easy. All of theses need only 5 lines changes :
      <itemizedlist>
	<listitem>
	  <para>config.py : manage the global configuration</para>
	</listitem>
	<listitem>
	  <para>schedulingitem.py : manage the scheduling algorithms
	  of host/services
	  </para>
	</listitem>
      </itemizedlist>
    </para>
    <section>
      <title>Configuration part</title>
      <para>
	In the first one (config.py) we add an entry to the properties
	dict :
	‘flap_history’ : {’required’:False, ‘default’:'20′, ‘pythonize’: to_int, ‘class_inherit’ : [(Host, None), (Service, None)]},
	So this property will be an option, with 20 by default, and will
	be put in the Host and Service class with the name 'flap_history'.
      </para>
      <para>
	That's all for the configuration! Yes, no more add. Just one
	line :)
      </para>
    </section>
    <section>
      <title>Running part</title>
      <para>Now the scheduling part (schedulingitem.py). The hard code
	20 was used in 2 functions : add_flapping_change and
	update_flapping. From this file, we are in an object named self in
	Python. To access the 'flap_history' of the Host or Service class
	of this object, we just need to do :
	flap_history = self.__class__.flap_history
	Then we change occurences in the code :
	if len(self.flapping_changes) > flap_history:
	[...]
	r += i*(1.2-0.8)/flap_history + 0.8
	r = r / flap_history
      </para>
      <para>That's all. you can test and propose the patch in the devel
	list. We will thanks you and after some patchs proposal, you can
	ask for a git access, you will be a Shinken developer :)
      </para>
    </section>
    <section>
      <title>The perfect patch</title>
      <para>If you can also add this property in the documentation (/doc
	directory) it will be perfect :)
      </para>
    </section>
  </section>
</chapter>

