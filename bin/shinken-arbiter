#!/usr/bin/env python
#Copyright (C) 2009-2010 :
#    Gabes Jean, naparuba@gmail.com
#    Gerhard Lausser, Gerhard.Lausser@consol.de
#    Gregory Starck, g.starck@gmail.com
#
#This file is part of Shinken.
#
#Shinken is free software: you can redistribute it and/or modify
#it under the terms of the GNU Affero General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#Shinken is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU Affero General Public License for more details.
#
#You should have received a copy of the GNU Affero General Public License
#along with Shinken.  If not, see <http://www.gnu.org/licenses/>.


"""
This is the class of the Arbiter. It's role is to read configuration,
cuts it, and send it to other elements like schedulers, reactionner
or pollers. It is responsible for hight avaibility part. If a scheduler
is dead,
it send it's conf to another if available.
It also read order form users (nagios.cmd) and send orders to schedulers.
"""


import os
import sys
import getopt


# We try to raise up recusion limit on
# but we don't have resource module on windows
if os.name != 'nt':
    import resource
    # All the pickle will ask for a lot of recursion, so we must make
    # sure to set it at a high value. The maximum recursion depth depends
    # on the Python version and the process limit "stack size".
    # The factors used were aquired by testing a broad range of installations
    stacksize_soft, stacksize_hard = resource.getrlimit(3)
    if sys.version_info < (2,6):
        sys.setrecursionlimit(int(stacksize_soft * 0.65 + 1100))
    elif sys.version_info < (3,):
        sys.setrecursionlimit(int(stacksize_soft * 1.9 + 3200))
    else:
        sys.setrecursionlimit(int(stacksize_soft * 2.4 + 3200))


# Try to load shinken lib.
# Maybe it's not in our python path, so we detect it
# it so (it's a untar install) we add .. in the path
try:
    import shinken
except ImportError, e:
    if hasattr(sys.modules['__main__'], '__file__'):
        my_path = os.path.abspath(sys.modules['__main__'].__file__)
        elts = os.path.dirname(my_path).split(os.sep)[:-1]
        sys.path.append(os.sep.join(elts))
        elts.append('shinken')
        sys.path.append(os.sep.join(elts))


from shinken.daemons.arbiterdaemon import Arbiter, usage


# Here we go!
if __name__ == "__main__":
    # Manage the options
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hvrdc::w", ["help", "verify-config", "replace", "daemon", "config=", "debug=", "easter"])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage(sys.argv[0])
        sys.exit(2)
    # Default params
    config_files = []
    verify_only = False
    is_daemon = False
    do_replace = False
    debug = False
    debug_file = None
    for o, a in opts:
        if o in ("-h", "--help"):
            usage(sys.argv[0])
            sys.exit()
        elif o in ("-v", "--verify-config"):
            verify_only = True
        elif o in ("-r", "--replace"):
            do_replace = True
        elif o in ("-c", "--config"):
            config_files.append(a)
        elif o in ("-d", "--daemon"):
            is_daemon = True
        elif o in ("--debug"):
            debug = True
            debug_file = a
        else:
            print "Sorry, the option", o, a, "is unknown"
            usage(sys.argv[0])
            sys.exit()

    if len(config_files) == 0:
        print "Error : config file is need"
        usage(sys.argv[0])
        sys.exit(1)

    daemon = Arbiter(config_files, is_daemon, do_replace, verify_only, debug, debug_file)

    daemon.main()
