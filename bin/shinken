#!/usr/bin/env python

# Copyright (C) 2009-2012:
#    Gabes Jean, naparuba@gmail.com
#    Gerhard Lausser, Gerhard.Lausser@consol.de
#    Gregory Starck, g.starck@gmail.com
#    Hartmut Goebel, h.goebel@goebel-consult.de
#
# This file is part of Shinken.
#
# Shinken is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Shinken is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Shinken.  If not, see <http://www.gnu.org/licenses/>.

"""

Warning: THIS IS A PREVIEW, and ugly code that looks as a script.

"""

import optparse
import sys
import os
import re
import tempfile
import json
import shutil
import zipfile
import tarfile
import pycurl
import urllib
import ConfigParser
import imp
from StringIO import StringIO

try:
    import shinken
    from shinken.bin import VERSION
except ImportError:
    # If importing shinken fails, try to load from current directory
    # or parent directory to support running without installation.
    # Submodules will then be loaded from there, too.
    import imp
    imp.load_module('shinken', *imp.find_module('shinken', [os.path.realpath("."), os.path.realpath(".."), os.path.join(os.path.abspath(os.path.dirname(sys.argv[0])), "..")]))
    from shinken.bin import VERSION

from shinken.log import logger, cprint
from shinken.objects.config import Config


logger.set_level(logger.DEBUG)
logger.set_display_time(False)

CONFIG = {}

class Dummy():
    def __init__(self): pass

    def add(self, obj): pass
logger.load_obj(Dummy())


if os.name != 'nt':
    DEFAULT_CFG = os.path.expanduser('~/.shinken.ini')
else:
    DEFAULT_CFG = 'c:\\shinken\\etc\\shinken.ini'


        


if __name__ == '__main__':
    parser = optparse.OptionParser(
        """""",
        version="%prog " + VERSION)
    parser.add_option('--proxy', dest="proxy",
                      help="""Proxy URI. Like http://user:password@proxy-server:3128""")
    parser.add_option('-A', '--api-key',
                      dest="api_key", help=("Your API key for uploading the package to the Shinken.io website. If you don't have one, please go to your account page"))
    parser.add_option('-l', '--list', action='store_true',
                      dest="do_list", help=("List available commands"))
    

    if not os.path.exists(DEFAULT_CFG):
        logger.debug('Missing configuration file!')
    else:
        cfg = ConfigParser.ConfigParser()
        cfg.read(DEFAULT_CFG)
        for section in cfg.sections():
            if not section in CONFIG:
                CONFIG[section] = {}
            for (key, value) in cfg.items(section):
                CONFIG[section][key] = value

    # Main list of keywords for the first parameter
    keywords = {}
    cli_mods_dir = os.path.abspath(CONFIG['paths']['cli'])
    logger.debug ("WILL LOAD THE CLI DIR %s" %  cli_mods_dir)
    cli_mods_dirs = [os.path.join(cli_mods_dir, d) for d in os.listdir(cli_mods_dir) if os.path.isdir(os.path.join(cli_mods_dir, d))]
    print "BLA?", cli_mods_dirs
    cli_mods = []
    for d in cli_mods_dirs:
        f = os.path.join(d, 'cli.py')
        print "EXISTS?", f
        if os.path.exists(f):
            dname = os.path.split(d)[1]
            # Let's load it, but first att it to sys.path
            sys.path.append(d)
            m = imp.load_source(dname, f)
            cli_mods.append(m)
            # Link the CONFIG objet into it
            m.CONFIG = CONFIG
            exports = getattr(m, 'exports', {})
            for (f, v) in exports.iteritems():
                m_keywords = v.get('keywords', [])
                for k in m_keywords:
                    e = {'f':f, 'args' : v.get('args', []),
                         'description':v.get('description', '')}
                    keywords[k] = e 
                         
    print "WE LOAD", cli_mods
    print "And keywords", keywords



    def hack_sys_argv():
        
        command_values = []
        internal_values = []
        #print "RARGS", parser.rargs
        founded = False
        for arg in sys.argv:
            print "IS ARG", arg, "in", keywords
            if arg in keywords:
                print "FOUNDED!"
                founded = True
            # Did we found it?
            if founded:
                command_values.append(arg)
            else: # ok still not, it's for the shinekn command so
                internal_values.append(arg)

        print "INTERNAL", internal_values
        print "COMMAND", command_values

        sys.argv = internal_values
        return command_values
            
    # We will remove specific commands from the sys.argv list and keep
    # them for parsing them after
    command_args = hack_sys_argv()
    
    opts, args = parser.parse_args()
    print "VAR ARGS", command_args

    # If the user explicitely set the proxy, take it!
    if opts.proxy:
        CONFIG['shinken.io.proxy'] = opts.proxy

    # Maybe he/she just want to list our commands?
    if opts.do_list:
        print "Available commands:"
        for (k,m) in keywords.iteritems():
            cprint('%s ' %  k , 'green', end='')
            cprint(': %s' %  m['description'])

            #print k,':', m.get('description', '')
        sys.exit(2)
    
    # if just call shinken, we must open a prompt, but will be for another version
    if len(command_args) == 0:
        parser.print_help()
        sys.exit(0)

    print "ARGS", command_args
    keyword = command_args.pop(0)
    mod = keywords.get(keyword, None)
    if mod is None:
        logger.error("UNKNOWN command %s" % keyword)
        sys.exit(2)
    
    # Now prepare a new parser, for the command call this time
    command_parser = optparse.OptionParser(
        """""",
        version="%prog " + VERSION)
    command_parser.prog = keyword

    f_args = []
    for a in mod.get('args', []):
        n = a.get('name', None)
        if n is None:
            continue
        default = a.get('default', Dummy)
        description = a.get('description', '')
        
    print "PARSE"
    cmd_opts, cmd_args = command_parser.parse_args(command_args)
    print "FIN PARSE"

    print "Load mod", mod

    f = mod.get('f', None)
    print "GOT ARGS", cmd_args
    f(*cmd_args)

