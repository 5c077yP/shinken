#!/bin/sh

### BEGIN INIT INFO
# Provides:          shinken
# Required-Start:    $local_fs
# Required-Stop:     $local_fs
# Default-Start:     2 3 4 5
# Default-Stop:      S 0 1 6
# Short-Description: Shinken monitoring daemon
# Description:       Shinken is a monitoring tool composed of many separated modules:
#     - arbiter     : the main one : control everything else.
#     - scheduler   : receives checks/actions from arbiter. Schedules & forwards them to pollers.
#     - poller      : receives the checks from a scheduler. Launch them and returns results
#     - broker      : manage results by looking at scheduler. Like export to flat file or db.
#     - reactionner : manage the failed checks by looking at scheduler. 
#     - receiver    : manage all passive data
### END INIT INFO

NAME="shinken"

AVAIL_MODULES="scheduler poller reactionner broker receiver arbiter"

## SHINKEN_MODULE_FILE is set by shinken-* if it's one of these that's calling us.
if [ -z "$SHINKEN_MODULE_FILE" ]; then
    SCRIPTNAME=$0
    _usage_mods_="[ <$AVAIL_MODULES> ]"
else
    SCRIPTNAME=$SHINKEN_MODULE_FILE
fi

curpath=$(dirname "$0")

## Default paths :
BIN="/usr/local/shinken/bin"
VAR="/usr/local/shinken/var"
ETC="/usr/local/shinken/etc"

export PATH="${PATH:+$PATH:}/usr/sbin:/bin:/sbin"

# default
DEBUG=false
CMD=""
SUBMODULES=""

## This permits to overhidde the default "default shinken cfg file" : 
[ -z "$SHINKEN_DEFAULT_FILE" ] && SHINKEN_DEFAULT_FILE="/etc/default/$NAME" 
## so you can now do:
## bash -c "SHINKEN_DEFAULT_FILE=$your_own_default_file $init_path/shinken $action $args"
## to easily use your own config

usage() {
    cat << EOT
Usage: $SCRIPTNAME [ -d ] [ -m <submodule> ] <command>

 -h|--help     show this help message
 -d|--debug    start requested module(s) in debug mode, only useful with start|restart
 <command>     command: start|stop|restart|status|check|checkconfig
 -m|--module   $_usage_mods_
EOT
}

# option parsing (not getopt way to allow command without dash or double dash to be called)
eval set -- "$@ --"

while true ; do
    case "$1" in
        -h|--help) 
            usage
            exit 0 
            ;;
        -d|--debug) 
            DEBUG=true
            shift 1
            ;;
	-c|--command)
	    [ -z "$CMD" ] && CMD=$2 || {
		echo "You can't specify more than one command !"
		exit 1
	    }
	    shift 2
	    ;;
	-m|--module)
	    SUBMODULES="$SUBMODULES $2"
	    shift 2
	    ;;
	start|stop|restart|status|check|checkconfig) 
            CMD=$1
            shift 1
            ;;
     
        --) 
            shift
            break 
            ;;
        *) echo "Unrecognized option: $1" >&2 ; exit 1 ;;
    esac
done

# Reads configuration variable file if it is present
[ -r "$SHINKEN_DEFAULT_FILE" ] && . "$SHINKEN_DEFAULT_FILE"

# Load the VERBOSE setting and other rcS variables
[ -f /etc/default/rcS ] && . /etc/default/rcS

# Define LSB log_* functions.
. /lib/lsb/init-functions

# Checking for sub modules availability
if [ ! -z "$SUBMODULES" ]; then
   # check given modules
    for mod1 in $SUBMODULES; do
        found=0
        for mod2 in $AVAIL_MODULES; do
            [ $mod1 = $mod2 ] && found=1;
        done
        [ $found = 0 ] && { usage >&2 ; exit 2 ; }
    done
else
    SUBMODULES=$AVAIL_MODULES
fi

################################################

#
# returns the pid file of a submodule
#
getvar() {
    mod=$1
    suffix=$2
    eval "var=$`echo ${mod} | tr '[:lower:]' '[:upper:]'`${suffix}"
    echo $var
}

#
# returns the pid file of a submodule
#
getpidfile() {
    echo $(getvar $1 "PID")
}

#
# returns the daemon variable name of a submodule
#
getdaemon() {
    echo $(getvar $1 "DAEMON")
}

#
# returns the configuration daemon variable name of a submodule
#
getconffile() {
    echo $(getvar $1 "CFG")
}


#
# set some variables regarding a submodule
#
load_env() {
    mod=$1
    daemon=$(getdaemon $mod)
    pidfile=$(getpidfile $mod)

    if [ "${mod}" != "arbiter" ]; then
	configfile=$(getconffile $mod)
	
        # rescue in case /etc/defaut/shiken do not exists
	[ -z "$configfile" ] && configfile="$ETC/${mod}d.ini"
	[ -r $configfile ] || {
	    echo "FAILED: no configuration file has been found !"
	    return 5
	}
	[ -z "${pidfile}" ] && eval `grep pidfile ${configfile}`
    fi
    
    [ -z "${pidfile}" ] && pidfile="$VAR/${mod}d.pid"
    [ -z "${daemon}" ] && daemon="$BIN/shinken-${mod}"

    if [ "${mod}" = "arbiter" ]; then
	[ -z "${SHINKENCFG}" ] && SHINKENCFG="$ETC/nagios.cfg"
	[ -z "${SHINKENSPECIFICCFG}" ] && SHINKENSPECIFICCFG="$ETC/shinken-specific.cfg"
    fi
}

#
# do an action on a submodule
#
do_action() {
    action=$1
    mod=$2
    load_env $mod
    

    # now, we can continue and launch the daemon
    [ -x "$daemon" ] || {
        echo "FAILED: did not found $mod file ($daemon) or file is not executable; are you sure shinken-$mod is installed ?"
        return 5
    }

    $DEBUG && {
	echo "Debugging informations will be saved in $VAR/${mod}-debug.log"
	DEBUGCMD="--debug $VAR/${mod}-debug.log"
    }
    OPT="-d -c ${SHINKENCFG} -c ${SHINKENSPECIFICCFG}"
    [ "$mod" != "arbiter" ] && OPT="-d -c ${configfile}"
    case $action in
	start)
	    log_progress_msg "Starting $mod daemon: "
	    start-stop-daemon --start -v --pidfile $pidfile --retry 3 --exec /usr/bin/python -- $daemon $OPT $DEBUGCMD > /dev/null
	    rt=$?
	    
	    [ $rt -eq 0 ] && log_success_msg "started" || log_failure_msg "failed: $!"
	    ;;
	stop)
	    log_progress_msg "Stopping $mod daemon: "
	    start-stop-daemon --stop -v -m --pidfile $pidfile --retry 3 > /dev/null
	    rt=$?
	    
	    [ $rt -eq 0 ] && { 
		rm -f $pidfile 
		log_success_msg "stopped" 
	    } || log_failure_msg "failed: $!"
	    ;;
	status)
	    pid=$(pidofproc -p $pidfile)
	    rt=$?
	    
	    case $rt in
		0)
		    log_success_msg "$daemon is running ($pid)"
		    ;;
		1) 
		    log_failure_msg "$pidfile found but no process is running"
		    ;;
		3)
		    log_failure_msg "no process is running"
		    ;;
		4)
		    log_failure_msg "$pidfile not found"
		    ;;

		*)
		    log_failure_msg "an error occured"
		    ;;
	    esac
	    ;;
	check)
	    /usr/bin/python $daemon -v -c ${SHINKENCFG} -c ${SHINKENSPECIFICCFG}
	    ;;
	*)
	    log_failure_msg "unknown action $action"
	    rt=5
    esac

    return $rt
}


############################
## Main:

case "$CMD" in
    start|stop|status)
	for module in $SUBMODULES; do
            do_action $CMD "$module"
	done
        ;;
    restart)
	for module in $SUBMODULES; do
            do_action "stop" "$module"
            do_action "start" "$module"
	done
	;;
    check|checkconfig)
        do_action "check" "arbiter"
        ;;
    *)
        usage >&2
        exit 2
        ;;
esac
