from command import CommandCall
from copy import deepcopy
#import time

class Service:
    id = 0
    properties={'host_name' : {'required':True},
            'hostgroup_name' : {'required':True},
            'service_description' : {'required':True},
            'display_name' : {'required':False , 'default':None},
            'servicegroups' : {'required':False, 'default':''},
            'is_volatile' : {'required':False, 'default':'0'},
            'check_command' : {'required':True},
            'initial_state' : {'required':False, 'default':'o'},
            'max_check_attempts' : {'required':True},
            'check_interval' : {'required':True},
            'retry_interval' : {'required':True},
            'active_checks_enabled' : {'required':False, 'default':'1'},
            'passive_checks_enabled' : {'required':False, 'default':'1'},
            'check_period' : {'required':True},
            'obsess_over_service' : {'required':False, 'default':'0'},
            'check_freshness' : {'required':False, 'default':'0'},
            'freshness_threshold' : {'required':False, 'default':'0'},
            'event_handler' : {'required':False, 'default':''},
            'event_handler_enabled' : {'required':False, 'default':'0'},
            'low_flap_threshold' : {'required':False, 'default':'25'},
            'high_flap_threshold' : {'required':False, 'default':'50'},
            'flap_detection_enabled' : {'required':False, 'default':'1'},
            'flap_detection_options' : {'required':False, 'default':'o,w,c,u'},
            'process_perf_data' : {'required':False, 'default':'1'},
            'retain_status_information' : {'required':False, 'default':'1'},
            'retain_nonstatus_information' : {'required':False, 'default':'1'},
            'notification_interval' : {'required':True},
            'first_notification_delay' : {'required':False, 'default':'0'},
            'notification_period' : {'required':True},
            'notification_options' : {'required':False, 'default':'w,u,c,r,f,s'},
            'notifications_enabled' : {'required':False, 'default':'1'},
            'contacts' : {'required':True},
            'contact_groups' : {'required':True},
            'stalking_options' : {'required':False, 'default':'o,w,u,c'},
            'notes' : {'required':False, 'default':''},
            'notes_url' : {'required':False, 'default':''},
            'action_url' : {'required':False, 'default':''},
            'icon_image' : {'required':False, 'default':''},
            'icon_image_alt' : {'required':False, 'default':''},
            'failure_prediction_enabled' : {'required':False, 'default':'0'},
            'parallelize_check' : {'required':False, 'default':'1'}
            }
    
    
    
    def __init__(self, params={}):
        self.id = self.__class__.id#Host.id
        #Host.id = Host.id + 1
        self.__class__.id += 1
        #self.id = Service.id
        #Service.id = Service.id + 1
        self.customs = {} # for custom variables
        self.plus = {} # for value with a +
        for key in params:
            if params[key][0] == '+':
                self.plus[key] = params[key][1:] # we remove the +
            elif key[0] == "_":
                self.customs[key] = params[key]
            else:
                setattr(self, key, params[key])

    def clean(self):
        pass

    #Use to make pyton properties
    def pythonize(self):
        try:
            self.active_checks_enabled = bool(self.active_checks_enabled)
            self.retry_interval = int(self.retry_interval)
            self.obsess_over_service = bool(self.obsess_over_service)
            self.is_volatile = bool(self.is_volatile)
            self.low_flap_threshold = bool(self.low_flap_threshold)
            self.process_perf_data = bool(self.process_perf_data)
            self.notification_interval = int(self.notification_interval)
            self.failure_prediction_enabled = bool(self.failure_prediction_enabled)
            self.flap_detection_options = self.flap_detection_options.split(',')
            self.retain_status_information = bool(self.retain_status_information)
            self.stalking_options = self.stalking_options.split(',')
            self.event_handler_enabled = bool(self.event_handler_enabled)
            self.first_notification_delay = int(self.first_notification_delay)
            self.flap_detection_enabled = int(self.flap_detection_enabled)
            self.notification_options = self.notification_options.split(',')
            self.high_flap_threshold = int(self.high_flap_threshold)
            self.retain_nonstatus_information = bool(self.retain_nonstatus_information)
            self.notifications_enabled = bool(self.notifications_enabled)
            self.freshness_threshold = int(self.freshness_threshold)
            self.parallelize_check = bool(self.parallelize_check)
            self.passive_checks_enabled = bool(self.passive_checks_enabled)
            self.check_interval = int(self.check_interval)
            self.max_check_attempts = int(self.max_check_attempts)
            self.check_freshness = bool(self.check_freshness)
        except AttributeError as exp:
            print "Bad value for the service...", exp," it's bad for the check..."

    def is_tpl(self):
        try:
            return self.register == '0'
        except:
            return False

    def copy(self):
        s = deepcopy(self)
        s.id = Service.id
        Service.id = Service.id + 1
        return s

    def has(self, prop):
        try:
            getattr(self,prop)
        except:
            return False
        return True

    def has_plus(self, prop):
        try:
            self.plus[prop]
        except:
            return False
        return True

    def get_plus_and_delete(self, prop):
        val = self.plus[prop]
        del self.plus[prop]
        return val

    #If a prop is absent and is not required, put the default value
    def fill_default(self):
        for prop in Service.properties:
            if not self.has(prop) and not Service.properties[prop]['required']:
                value = Service.properties[prop]['default']
                setattr(self, prop, value)


    def get_templates(self):
        if self.has('use'):
            return self.use.split(',')
        else:
            return []
    
    #We fillfull properties with template ones if need
    def get_property_by_inheritance(self, services, prop):
        if self.has(prop):
            value = getattr(self, prop)
            if self.has_plus(prop):#Manage the additive inheritance for the property, if property is in plus, add or replace it
                value = value+','+self.get_plus_and_delete(prop)
            return value
        tpls = self.get_templates()
        for tpl in tpls:
            s = services.find_tpl_by_name(tpl)
            if s is not None:
                value = s.get_property_by_inheritance(services, prop)
                if value is not None:
                    if self.has_plus(prop):
                        value = value+','+self.get_plus_and_delete(prop)
                    setattr(self, prop, value)
                    return value
        if self.has_plus(prop):
            value = self.get_plus_and_delete(prop)
            setattr(self, prop, value)
            return value
        return None

    #We fillfull properties with template ones if need
    def get_customs_properties_by_inheritance(self, services):
        cv = {} # custom variables dict
        tpls = self.get_templates()
        for tpl in tpls:
            s = services.find_tpl_by_name(tpl)
            tpl_cv = s.get_customs_properties_by_inheritance(services)
            if tpl_cv is not {}:
                for prop in tpl_cv:
                    if prop not in self.customs:
                        value = tpl_cv[prop]
                    else:
                        value = self.customs[prop]
                    if self.has_plus(prop):
                        value = value+self.get_plus_and_delete(prop)
                    self.customs[prop]=value
        for prop in self.customs:
            value = self.customs[prop]
            if self.has_plus(prop):
                value = value = value+','+self.get_plus_and_delete(prop)
                self.customs[prop] = value
        #We can get custom properties in plus, we need to get all entires and put
        #them into customs
        cust_in_plus = self.get_all_plus_and_delete()
        for prop in cust_in_plus:
            self.customs[prop] = cust_in_plus[prop]
        return self.customs

    
    def get_all_plus_and_delete(self):
        res = {}
        props = self.plus.keys() #we delete entries, so no for ... in ...
        for prop in props:
            res[prop] = self.get_plus_and_delete(prop)
        return res
    
    def __str__(self):
        return str(self.__dict__)+'\n'


class Services:
    def __init__(self, services):
        self.services = {}
        for s in services:
            self.services[s.id] = s

    
    def find_srv_id_by_name_and_hostname(self, host_name, name):
        for id in self.services:
            if self.services[id].has('service_description') and self.services[id].has('host_name'):
                if self.services[id].service_description == name and self.services[id].host_name == host_name:
                    return id
        return None


    def find_srv_by_name_and_hostname(self, host_name, name):
        id = self.find_srv_id_by_name_and_hostname(host_name, name)
        if id is not None:
            return self.services[id]
        else:
            return None


    def linkify(self, hosts, commands, timeperiods, contacts):
        self.linkify_s_by_hst(hosts)
        self.linkify_s_by_cmd(commands)
        self.linkify_s_by_tp(timeperiods)
        self.linkify_s_by_c(contacts)

    #We just search for each host the id of the host
    #and replace the name by the id
    def linkify_s_by_hst(self, hosts):
        for id in self.services:
            try:
                hst_name = self.services[id].host_name
                
                #The new member list, in id
                hst = hosts.find_host_by_name(hst_name)
                self.services[id].host_name = hst
            except:
                pass#problem wil be check at is_correct function


    def linkify_s_by_cmd(self, commands):
        for id in self.services:
            self.services[id].check_command = CommandCall(commands, self.services[id].check_command)


    def linkify_s_by_tp(self, timeperiods):
        for id in self.services:
            try:
                #notif period
                ntp_name = self.services[id].notification_period
                ntp = timeperiods.find_tp_by_name(ntp_name)
                self.services[id].notification_period = ntp
            except:
                pass
            try:
                #Check period
                ctp_name = self.services[id].check_period
                ctp = timeperiods.find_tp_by_name(ctp_name)
                self.services[id].check_period = ctp
            except:
                pass #problem will be check at is_correct fucntion


    def linkify_s_by_c(self, contacts):
        for id in self.services:
            s = self.services[id]
            contacts_tab = s.contacts.split(',')
            new_contacts = []
            for c_name in contacts_tab:
                c_name = c_name.strip()
                c = contacts.find_cont_by_name(c_name)
                new_contacts.append(c)
                
            s.contacts = new_contacts


    #We remove useless properties
    def clean_useless(self):
        #First templates
        tpls = [id for id in self.services if self.services[id].is_tpl()]
        for id in tpls:
            del self.services[id]

    
    def delete_services_by_id(self, ids):
        for id in ids:
            del self.services[id]


    #Inheritance forjust a property
    def apply_partial_inheritance(self, prop):
        #print "checking for prop:", prop, "on", len(self.services), "services"
        for id in self.services:
            s = self.services[id]
            s.get_property_by_inheritance(self, prop)


    def apply_implicit_inheritance(self, hosts):
        for prop in ['contact_groups', 'notification_interval' , 'notification_period']:
            for id in self.services:
                s = self.services[id]
                if not s.is_tpl():
                    if not s.has(prop) and s.has('host_name'):
                        h = hosts.find_host_by_name(s.host_name)
                        if h is not None and h.has(prop):
                            setattr(s, prop, getattr(h, prop))


    def apply_inheritance(self, hosts):
        #We check for all Host properties if the host has it
        #if not, it check all host templates for a value
        for prop in Service.properties:
            self.apply_partial_inheritance(prop)

        #Then implicit inheritance
        self.apply_implicit_inheritance(hosts)
        for id in self.services:
            s = self.services[id]
            s.get_customs_properties_by_inheritance(self)
            

    def find_tpl_by_name(self, name):
        for id in self.services:
            s = self.services[id]
            if s.is_tpl() and s.name == name:
                return s
        return None


    def __str__(self):
        s = ''
        for id in self.services:
            s = s + 'Service:' + str(id)  + str(self.services[id])  + '\n'
        return s


    #If a prop is absent and is not required, put the default value
    def fill_default(self):
        for id in self.services:
            s = self.services[id]
            s.fill_default()


    def pythonize(self):
        for id in self.services:
            self.services[id].pythonize()


    #We look for contacts property in contacts and
    def explode(self, hostgroups, contactgroups, servicegroups):
        #Hostgroups property need to be fullfill for got the informations
        self.apply_partial_inheritance('contact_groups')
        self.apply_partial_inheritance('hostgroup_name')
        self.apply_partial_inheritance('host_name')

        #The "old" services will be removed. All services with 
        #more than one host or a host group will be in it
        srv_to_remove = []
        
        #We adding all hosts of the hostgroups into the host_name property
        #because we add the hostgroup one AFTER the host, they are before and 
        #hostgroup one will NOT be created
        for id in self.services:
            s = self.services[id]
            if s.has('hostgroup_name'):
                hgnames = s.hostgroup_name.split(',')
                for hgname in hgnames:
                    hgname = hgname.strip()
                    hnames = hostgroups.get_members_by_name(hgname)
                    #We add hosts in the service host_name
                    if s.has('host_name'):
                        s.host_name += ','+hnames
                    else:
                        s.host_name = hnames

        #We adding all hosts of the hostgroups into the host_name property
        #because we add the hostgroup one AFTER the host, they are before and 
        #hostgroup one will NOT be created
        for id in self.services:
            s = self.services[id]
            if s.has('contact_groups'):
                cgnames = s.contact_groups.split(',')
                for cgname in cgnames:
                    cgname = cgname.strip()
                    cnames = contactgroups.get_members_by_name(cgname)
                    #We add hosts in the service host_name
                    if cnames != []:
                        if s.has('contacts'):
                            s.contacts += ','+cnames
                        else:
                            s.contacts = cnames
        
        #Then for every host create a copy of the service with just the host
        service_to_check = self.services.keys() #because we are adding services, we can't just loop in it
        for id in service_to_check:
            s = self.services[id]
            if not s.is_tpl(): #Exploding template is useless
                hnames = s.host_name.split(',')
                if len(hnames) >= 2:
                    for hname in hnames:
                        hname = hname.strip()
                        new_s = s.copy()
                        new_s.host_name = hname
                        self.services[new_s.id] = new_s
                    srv_to_remove.append(id)
        
        self.delete_services_by_id(srv_to_remove)

        #Servicegroups property need to be fullfill for got the informations
        self.apply_partial_inheritance('servicegroups')
        for id in self.services:
            s = self.services[id]
            if not s.is_tpl():
                sname = s.service_description
                shname = s.host_name
                if s.has('servicegroups'):
                    sgs = s.servicegroups.split(',')
                    for sg in sgs:
                        servicegroups.add_member(shname+','+sname, sg)
        
